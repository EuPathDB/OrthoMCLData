#!/usr/bin/perl

use strict;
use Bio::Tools::BPlite;
use Data::Dumper;

my $blastFile = shift(@ARGV);
my @fastaFiles = @ARGV;

usage() unless $blastFile;

usage unless scalar(@fastaFiles) > 1;
 
my $genes = processFastaFiles(@fastaFiles);

open(F,$blastFile) || die "can't open BLAST file '$blastFile'\n";

=pod
query_name, hitname, 
$pcid, len, 
mismatches, ngaps, 
start('query'), end('query'),
start('hit'), end('hit'),
evalue, bits
=cut

my $genes = getGenesFromFasta(@fastaFiles);

my $prevSubjectId = 'blah';
my $subject;  # hash to hold subject info
my $queryShorter;

while(<F>) {
    my ($queryId, $subjectId, $percentIdentity, $length, $mismatches, $ngaps, $queryStart, $queryEnd, $subjectStart, $subjectEnd, $evalue, $bits) = split;

    if ($subjectId ne $prevSubjectId) {

	# print previous subject
	printPreviousSubject($subject) if $subject;

	# initialize new one from first HSP
	$prevSubjectID = $subjectId;

	$subject = {}; 
	$subject->{queryShorter} = getTaxonAndLength($subject, $genes);
	
	($subject->{evalue_mant}, $subject->{evalue_exp}) 
	    = formatEval($evalue); # from first hsp
    }

    # get additional info from subsequent HSPs
    my $hspspan = [$subjectStart, $subjectEnd];
    $hspspan = [$queryStart, $queryEnd] if $subject->{queryShorter};
    push(@{$subject->{hspspans}}, $hspspan);
    $subject->{totalIdentities} += $percentIdentity * $length;
    $subject->{totalLength} += $length;
}
printPreviousSubject($subject);

########################################################################################

sub getGenesFromFasta {
    my (@fastaFiles) = @_;

    my $genes;
    foreach my $fastaFile (@fastaFiles) {
	$fastaFile =~ /(\S+).fasta/ || die "'$fastaFile' is not in 'taxon.fasta' format\n";
	my $taxon = $1;
	open(FF,$fastaFile) || "die can't open fasta file '$fastaFile'";
	my $gene;
	while (<FF>) {
	    chomp;
	    next if /^\s*$/;
	    if (/\>(\S+)/) {
		$genes->{$gene}->{length} = $length if $gene;
		$genes->{$gene}->{taxon} = $taxon if $gene;
		$gene = $1;
		$length = 0;
	    } else {
		$length += length($_);
	    }
	}
	$genes->{$gene}->{length} = $length if $gene;
	$genes->{$gene}->{taxon} = $taxon if $gene;
	close(FF);
    }
    return $genes;
}

sub getTaxonAndLength {
    my ($subject, $genes) = @_;
    $subject->{queryTaxon} = $genes->{$queryId}->{taxon};
    $subject->{subjectTaxon} = $genes->{$subjectId}->{taxon};
    $subject->{queryLength} = $genes->{$queryId}->{length};
    $subject->{subjectLength} = $genes->{$subjectId}->{length};
    die "couldn't find taxon for gene '$subjectId'" unless $subjectTaxon;
    die "couldn't find taxon for gene '$queryId'" unless $queryTaxon;
    return $subject->{queryLength} < $subject->{subjectLength};
}

sub printPreviousSubject {
    my ($subject) = @_;

    my $nonOverlapMatchLen = computeNonOverlappingMatchLength($subject);

    my $subject->{percentIdentity} =
	int($subject->{totalIdentities} / $subject->{totalLength});
    my $shorterLength = $subject->{queryShorter}? $subject->{queryLength} : $subject->{subjectLength};
    my $subject->{percentMatch} = int($nonOverlapMatchLen / $shorterLength * 1000 + .5) / 10;
    print "$queryId, $subjectId, $query_taxon, $subject_taxon, $evalue_mant, $evalue_exp, $percentIdent, $percentMatch\n";
}

sub formatEvalue {
    my ($evalue) = @_;
    $evalue = '1' . $evalue if ($evalue =~ /^e/);
    my ($evalue_mant, $evalue_exp) = split(/e\-/, $evalue);
    ($evalue_mant, $evalue_exp) = (0,0) if $evalue eq '0.';
    $evalue_exp = 0 unless $evalue_exp;
    return ($evalue_mant, $evalue_exp);
}

sub getNonoverlappingQueryMatchLength {
    my ($subject) = @_;

    my @hsps = sort {$a->[0] <=> $b->[0]} @{$subject->{hsps}};
    my $first = shift @hsps;
    return 0 unless $first;
    my $start = $first->[0]; 
    my $end = $first->[1]; 
    my $len = 0;
    foreach my $h (@hsps){
      next if $h->[1] <= $end; ##does not extend
      if($h->[0] <= $end){  ##overlaps
        $end = $h->[1];  #extend end ... already dealt with if new end is less
      }else{  ##there is a gap in between ..
        $len += $end - $start + 1;
        $start = $h->[0];
        $end = $h->[1];
      }
    }
    $len += $end - $start + 1; # deal with the last one 
    return $len
  }
  return $self->{"totalQueryMatchLength"};
}


sub usage {
  print "

orthomclBlastParser blast_file xxxxx.fasta yyyyy.fasta ...

where:
  blast_file:  BLAST output in m8 format.
  xxxxxx.fasta: name of a multi-fasta file containing one genome's proteins or genes.  'xxxxx' is used as a unique identifier of that genome.
  
output is a tab file, with one row per subject. these are the columns:

query_id subject_id query_taxon subject_taxon evalue_mant evalue_exp percentIdent percentMatch

";
  exit(1);
}
