#!/usr/bin/perl

use strict;
use DBI;
use DBD::Oracle;
use DBD::mysql;

=pod
SimilarSequences
| InterTaxonMatch
| | BestQueryTaxonScore
| | | BestInterTaxonScore
| | | | BetterHit
| | | | | InParalog ***
| | | | | | InParalog2way--------|
| | | BestHit                    |
| | | | Ortholog ***             |
| | | | | Ortholog2way           |
| | | | | | CoOrthologCandidate -|
| | | | | | | CoOrtholog ***
=cut

my $configFile = $ARGV[0];
my $only = $ARGV[1];

&usage() unless $configFile;

my $config = parseConfigFile($configFile);
my $sst = $config->{similarSequencesTable};

my $dbh = DBI->connect($config->{dbConnectString}, $config->{dbLogin},
		       $config->{dbPassword}) or die DBI::errstr;

commonTempTables();

inparalogs() unless $only eq '-orthologsOnly';

orthologs() unless $only eq '-inparalogsOnly';

normalizeInparalogs() unless $only eq '-orthologsOnly';

coorthologs() unless $only;

############################################################################

sub parseConfigFile {
  my ($configFile) = @_;

  open(F, $configFile) || die "Can't open config file '$configFile'\n";

  my $config;
  while(<F>) {
    /(\w+)\=(.+)/ || "illegal line in config file '$_'\n";
    $config->{$1} = $2;
  }
  return $config;
}

sub commonTempTables {
  print STDERR "
Constructing common temp tables:
  - update SimilarSequences evalue_exp, setting 0 values to the minimum evalue_exp-1
  - create BestQueryTaxonScore
";
  validateInputTables();
  updateMinimumEvalueExponent();
  #interTaxonMatch();
  bestQueryTaxonScore();
}

sub inparalogs {
  print STDERR "
Constructing InParalog tables:
  - create BestInterTaxonScore temp table
  - create BetterHit temp table
  - populate InParalog
";
  bestInterTaxonScore();
  betterHit();
  inParalog();
}

sub orthologs {
  print STDERR "
Constructing Ortholog tables:
  - create BestHit temp table
  - populate Ortholog table
  - update Ortholog, setting normalized_score
";
  bestHit();
  ortholog();
  normalizeOrthologs();
}

sub normalizeInparalogs {
  my $inParalogTable = $config->{inParalogTable};
  my $orthologTable = $config->{orthologTable};

  my $sql = "
update $inParalogTable i
set normalized_score = (
 select i.unnormalized_score / t.average
 from    (
     select decode(haveOrthologsAvg.average, null,
                   allInparalogsAvg.average,
                   haveOrthologsAvg.average) average,
             allInparalogsAvg.taxon_id
     from
       (
         select avg(i2.unnormalized_score) average, i2.taxon_id
         from apidb.InParalog i2
         group by i2.taxon_id
       ) allInparalogsAvg,
       (
         select avg(i2.unnormalized_score) average, i2.taxon_id
         from apidb.InParalog i2
         where (i2.sequence_id_a in
                 (select sequence_id_a from apidb.Ortholog
                  union
                  select sequence_id_b from apidb.Ortholog
                  )
            or i2.sequence_id_b in 
                 (select sequence_id_a from apidb.Ortholog
                  union 
                  select sequence_id_b from apidb.Ortholog)
              ) 
         group by i2.taxon_id
       ) haveOrthologsAvg
     where allInparalogsAvg.taxon_id = haveOrthologsAvg.taxon_id
   ) t
 where i.taxon_id = t.taxon_id
)
";
  runSql($sql, "update InParalogs, setting normalized_score");
}

sub coorthologs {
  print STDERR "
Constructing CoOrtholog tables:
  - create InParalog2way temp table
  - create Ortholog2way temp table
  - create CoOrthologCandidate temp table
  - populate CoOrtholog
  - update CoOrtholog, setting normalized_score
";
  inParalog2way();
  ortholog2way();
  coorthologCandidate();
  coortholog();
  normalizeCoOrthologs();
}

sub validateInputTables {

}

sub updateMinimumEvalueExponent {
  my $sql = "
update $sst
set evalue_exp = (
  select min(evalue_exp)-1
  from $sst
  where evalue_mant != 0
)
where evalue_exp = 0
";
  runSql($sql, "updating $sst, setting 0 evalue_exp to underflow value");
}

#sub interTaxonMatch {
#  my $sql = "
#create view InterTaxonMatch as
#select ss.query_id, ss.subject_id, ss.subject_taxon_id,
#       ss.evalue_mant, ss.evalue_exp
#from $sst ss
#where ss.subject_taxon_id != ss.query_taxon_id
#";
#  runSql($sql, "creating view InterTaxonMatch");
#}

sub bestQueryTaxonScore {
  my $interTaxonMatch = $config->{interTaxonMatch};

  my $sql = "
create table BestQueryTaxonScore as
select im.query_id, im.subject_taxon_id, low_exp.evalue_exp, min(im.evalue_mant) as evalue_mant
from $interTaxonMatch im,
     (select query_id, subject_taxon_id, min(evalue_exp) as evalue_exp
      from $interTaxonMatch
      group by query_id, subject_taxon_id) low_exp
where im.query_id = low_exp.query_id
  and im.subject_taxon_id = low_exp.subject_taxon_id
  and im.evalue_exp = low_exp.evalue_exp
group by im.query_id, im.subject_taxon_id, low_exp.evalue_exp
";

  runSql($sql, "create BestQueryTaxonScore");
  $sql = "
create index qtscore_ix on BestQueryTaxonScore(query_id, subject_taxon_id, evalue_exp, evalue_mant)
";

  runSql($sql, "create qtscore_ix index on BestQueryTaxonScore");
}

sub  bestInterTaxonScore{
  my $sql = "
create table BestIntertaxonScore as
select im.query_id, low_exp.evalue_exp, min(im.evalue_mant) as evalue_mant
from BestQueryTaxonScore im,
     (select query_id, min(evalue_exp) as evalue_exp
      from BestQueryTaxonScore
      group by query_id) low_exp
where im.query_id = low_exp.query_id
  and im.evalue_exp = low_exp.evalue_exp
group by im.query_id, low_exp.evalue_exp
";
  runSql($sql, "");
}

sub  betterHit{
  my $sql = "
create table BetterHit as
select s.query_id, s.subject_id,
       s.query_taxon_id as taxon_id,
       s.evalue_exp, s.evalue_mant
from $sst s, BestIntertaxonScore bis
where s.query_id != s.subject_id
  and s.query_taxon_id = s.subject_taxon_id
  and s.query_id = bis.query_id
  and (s.evalue_mant < 0.001
       or s.evalue_exp < bis.evalue_exp
       or (s.evalue_exp = bis.evalue_exp and s.evalue_mant <= bis.evalue_mant))
-- . . . or Similarity for a protein with no BestIntertaxonScore
--       (i.e. an intrataxon match for a protein with no intertaxon
--        match in the database)
union
select s.query_id, s.subject_id, s.query_taxon_id as taxon_id, s.evalue_exp, s.evalue_mant
from $sst s
where s.query_taxon_id = s.subject_taxon_id
  and s.query_id in (select query_id from $sst
                     minus select query_id from BestIntertaxonScore)
";
  runSql($sql, "create BetterHit table");
}

sub  inParalog{
  my $sql = "
insert into InParalog
select bh1.query_id as sequence_id_a, bh1.subject_id as sequence_id_b,
       bh1.taxon_id,
       case -- don't try to calculate log(0) -- use rigged exponents of SimSeq
         when bh1.evalue_mant < 0.01 or bh2.evalue_mant < 0.01
           then (bh1.evalue_exp + bh2.evalue_exp) / -2
         else  -- score = ( -log10(evalue1) - log10(evalue2) ) / 2
           (log(10, bh1.evalue_mant * bh2.evalue_mant)
            + bh1.evalue_exp + bh2.evalue_exp) / -2
       end as unnormalized_score,
       cast(null as number) as normalized_score
from BetterHit bh1, BetterHit bh2
where bh1.query_id < bh1.subject_id
  and bh1.query_id = bh2.subject_id
  and bh1.subject_id = bh2.query_id
";
  runSql($sql, "populate InParalog");
}

sub bestHit {
  my $sql = "
create table BestHit as
select s.query_id, s.subject_id,
       s.query_taxon_id, s.subject_taxon_id,
       s.evalue_exp, s.evalue_mant
from $sst s, BestQueryTaxonScore cutoff
where s.query_id = cutoff.query_id
  and s.subject_taxon_id = cutoff.subject_taxon_id
  and s.query_taxon_id != s.subject_taxon_id
  and (s.evalue_mant < 0.01
       or s.evalue_exp = cutoff.evalue_exp
          and s.evalue_mant = cutoff.evalue_mant)
";
  runSql($sql, "create BestHit");
}

sub ortholog {
  my $orthologTable = $config->{orthologTable};

  my $sql = "
insert into $orthologTable
select bh1.query_id as sequence_id_a, bh1.subject_id as sequence_id_b,
       bh1.query_taxon_id, bh1.subject_taxon_id,
       case -- don't try to calculate log(0) -- use rigged exponents of SimSeq
         when bh1.evalue_mant < 0.01 or bh2.evalue_mant < 0.01
           then (bh1.evalue_exp + bh2.evalue_exp) / -2
         else  -- score = ( -log10(evalue1) - log10(evalue2) ) / 2
           (log(10, bh1.evalue_mant * bh2.evalue_mant)
            + bh1.evalue_exp + bh2.evalue_exp) / -2
       end as unnormalized_score,
       cast(null as number) as normalized_score
from BestHit bh1, BestHit bh2
where bh1.query_id < bh1.subject_id
  and bh1.query_id = bh2.subject_id
  and bh1.subject_id = bh2.query_id
";
  runSql($sql, "populate Ortholog");
}

sub normalizeOrthologs {
  my $orthologTable = $config->{orthologTable};

  my $sql = "
update $orthologTable o
set normalized_score = (
  select o.unnormalized_score / t.average
  from (
    select avg(o2.unnormalized_score) average
    from $orthologTable o2
  ) t
)
";
  runSql($sql, "updating Orthologs, setting normalized_score");
}


sub  inParalog2way {
  my $inParalogTable = $config->{inParalogTable};

  my $sql = "
create table inparalog2way as
select sequence_id_a, sequence_id_b from $inParalogTable
union
select sequence_id_b as sequence_id_a, sequence_id_a as sequence_id_b from $inParalogTable
";
  runSql($sql, "create inParalog2way");
}

sub  ortholog2way {
  my $orthologTable = $config->{orthologTable};

  my $sql = "
create table ortholog2way as
-- symmetric closure of Ortholog
select sequence_id_a, sequence_id_b from $orthologTable
union
select sequence_id_b as sequence_id_a, sequence_id_a as sequence_id_b from $orthologTable
";
  runSql($sql, "create ortholog2way");

  $sql = "
create index in2a_ix on inparalog2way(sequence_id_a, sequence_id_b)
";
  runSql($sql, "index in2a_ix");

  $sql = "
create index in2b_ix on inparalog2way(sequence_id_b, sequence_id_a)
";
  runSql($sql, "index in2b_ix");
}

sub  coorthologCandidate {
  my $sql = "
create table CoorthologCandidate as
select distinct
       least(sequence_id_a, sequence_id_b) as sequence_id_a,
       greatest(sequence_id_a, sequence_id_b) as sequence_id_b
from (-- twp-way union, part 1: inparalog-ortholog-inparalog
      select ip1.sequence_id_a, ip2.sequence_id_b
      from inparalog2way ip1, ortholog2way o, inparalog2way ip2
      where ip1.sequence_id_b = o.sequence_id_a
        and o.sequence_id_b = ip2.sequence_id_a
   union -- part 2: ortholog-inparalog
      select ip.sequence_id_a, o.sequence_id_b
      from inparalog2way ip, ortholog2way o
      where ip.sequence_id_b = o.sequence_id_a)
";
  runSql($sql, "create CoOrthologCandidate");
}

sub  coortholog {
  my $orthologTable = $config->{orthologTable};
  my $coOrthologTable = $config->{coOrthologTable};

  my $sql = "
insert into $coOrthologTable (sequence_id_a, sequence_id_b, unnormalized_score)
select /*+ use_nl(candidate, ab) use_nl(candidate, ba)  */
       candidate.sequence_id_a as sequence_id_a, candidate.sequence_id_b as sequence_id_b,
       case  -- in case of 0 evalue, use rigged exponent
         when ab.evalue_mant < 0.00001 or ba.evalue_mant < 0.00001
           then (ab.evalue_exp + ba.evalue_exp) / -2
         else -- score = ( -log10(evalue1) - log10(evalue2) ) / 2
           (log(10, ab.evalue_mant * ba.evalue_mant)
            + ab.evalue_exp + ba.evalue_exp) / -2
       end as unnormalized_score
from $sst ab, $sst ba,
     (select sequence_id_a, sequence_id_b from CoorthologCandidate
      minus select sequence_id_a, sequence_id_b from $orthologTable) candidate
where ab.query_id = candidate.sequence_id_a
  and ab.subject_id = candidate.sequence_id_b
  and ba.query_id = candidate.sequence_id_b
  and ba.subject_id = candidate.sequence_id_a
";
  runSql($sql, "populate CoOrtholog");
}

sub normalizeCoOrthologs {
  my $coOrthologTable = $config->{coOrthologTable};

  my $sql = "
update $coOrthologTable c
set normalized_score = (
  select c.unnormalized_score / t.average
  from (
    select avg(c2.unnormalized_score) average
    from $coOrthologTable c2
  ) t
)
";
  runSql($sql, "updating CoOrthologs, setting normalized_score");
}

sub runSql {
  my ($sql, $msg, $sampleTime) = @_;

  my $t = time();

  print STDERR localtime() . "  $msg\n  (OrthoMCL V2 took $sampleTime for this step)\n";

  my $stmt = $dbh->prepare($sql) or die DBI::errstr;
  $stmt->execute() or die DBI::errstr;

  my $tt = time() - $t;
  my $hours = int($tt / 3600);
  my $mins = int($tt / 60) % 60;
  if ($hours == 0 && $mins == 0) {$mins = 1};
  print STDERR "  done ($hours hours and $mins mins)\n\n";

}

sub usage {
  print "
Find edges for OrthoMCL.

usage: orthomclEdges config_file [-orthologsOnly | -inparalogsOnly]

where:
  config_file : see below
  orthologsOnly : only output is Orthologs table
  inparalogsOnly : only output is InParalogs table

Database Input:
  - SimilarSequences table containing all-v-all BLAST hits
  - InParalog, Ortholog, CoOrtholog tables - created but empty

Database Output:
  - Populated InParalog, Ortholog and CoOrtholog tables

File Output:
  - matrix file as expected by MCL.


Sample Config File:

dbVender=oracle  (or mysql)
dbConnectString=dbi:Oracle:orthomcl
dbLogin=my_db_login
dbPassword=my_db_password
similarSequencesTable=apidb.SimilarSequences
orthologTable=apidb.Ortholog
inParalogTable=apidb.InParalog
coOrthologTable=apidb.CoOrtholog
interTaxonMatchTable=apidb.InterTaxonMatch
";
  exit(1);
}

